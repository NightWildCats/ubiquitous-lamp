<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>

<body>

  <script>
    // 4.1 基本类型和引用类型的值 
    // 基本类型值指的是简单的数据段，而引用类型指那些可能由多个值构成的对象。引用类型的值是保存在内存中的对象。js在操作对象时，实际上是在操作对象的引用而不是实际的对象。为此，引用类型的值是按引用访问的。
    
    // 4.1.1 动态的属性
    // 创建变量时，对于引用类型的值，我们可以为其添加属性和方法，也可以删除和改变其属性和方法（当复制保存着对象的某个变量时，操作的是对象的引用。但在为对象添加属性时，操作的是实际的对象）。

    //4.1.2 复制变量值
    // 如果从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上。而这两个变量可以参与任何操作而不会相互影响；
    // 如果从一个向另一个变量复制引用类型的值时，这个值实际上是一个指针，而这个指针指向存储在堆中的一个对象。而由于两个变量引用同一个对象。因此，改变其中一个变量，就会影响到另一个变量；

    // 4.1.3 传递参数
    // 所有函数的参数都是按值传递的。基本类型值的传递如同基本类型变量的复制，而引用类型值的传递，则如同引用类型变量的赋值一样（即参数可以是基本类型，也可以是对象）。
    function addTen(num){ 
      num += 10;
      return num;
    }
    var count = 20;
    var result = addTen(count);
    alert(count); //20，没有变化
    alert(result); //30


    function setName(obj){
      obj.name = "Nicholas";
      obj = new Object();
      obj.name = "Greg";
    }
    var person = new Object();
    setName(person);
    alert(person.name); // "Nicholas"
    // 即使在函数内部修改了参数的值，但原始的引用仍然保持未变。实际上，当在函数内部重写obj时，这个变量引用的就是一个局部对象了。而这个局部对象（ECMAScript函数的参数想象成局部变量）会在函数执行完毕后立即销毁。

    // 4.1.4 检测类型/
    // 检测基本数据类型，typeof是最佳的选择。但如果变量的值是一个对象或是null，则都将返回object；
    // 检测引用类型，可以使用instanceof操作符，其语法如下
    result = variable instanceof constructor; 
    // 例如
    console.log(person instanceof Object);  //变量person是Object吗？
    console.log(colors instanceof Array);   //变量colors是Array吗？
    console.log(pattern instanceof RegExp); //变量pattern是RegExp吗？

    // 理论上所有引用类型的值都是Object的实例。因此，在检测一个引用类型值和Object构造函数时，instanceof操作符始终会返回true；
    // 使用typeof 操作符检测函数时，该操作符会返回“function”。ECMA-262规定任何在内部实现[(call)] 方法的对象都将返回function。对正则表达式应用typpeof也会返回function。但在ie和firefox中，对正则表达式应用typeof会返回object

    // 4.2 执行环境及作用域
    // 全局执行环境是最外围的一个执行环境。其在web浏览器中，被认为是window对象。因此所有全局变量和函数都是作为window对象的属性和方法创建的。某个执行环境中的所有代码执行完毕后，该环境将被销毁，保存在其中的所有变量和函数定义也随之销毁（全局执行环境直到应用程序退出-例如关闭网页或浏览器-时才会被销毁）
    // 每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。ECMAScript程序中的执行流正是由这个方便的机制控制着。
    // 当代码在一个环境中执行时，会创建变量对象的一个作用域链。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象作为变量对象。活动对像在最开始时只包含一个变量，即arguments对象（这个对象在全局环境中是不存在的）
    // 标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直至找到标识符为止（如果找不到标识符，通常会导致错误产生）
    // 每个环境都可以向上搜索作用域链，但不能向下搜索。如果在当前所在作用域中无法找到，它会继续搜索上一级作用域链。当在最外层作用域（全局作用域）中仍未找到，则会报错

    // 4.2.1 延长作用域链
    // 1、try-catch语句的catch块；2、with语句。这两个语句都会在作用域链的前端添加一个变量对象。对with语句来说，会将指定的对象添加到作用域链中。对catch语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。

    //  4.2.2 没有块级作用域
    // 使用var声明的变量会自动被添加到最接近的环境中。如果初始化变量时没有使用var声明，该变量会自动被添加到全局环境。
   
    //  4.4 小结
    // javascript变量可以用来保存两种类型的值：基本类型值和引用类型值。基本类型的值源自于5种基本数据类型：undefined、null、boolean、number和string。基本类型值和引用类型值具有以下特点
      // 1、基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中，
      // 2、从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本，
      // 3、引用类型的值是对象，保存在堆内存中，
      // 4、包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针，
      // 5、从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象，
      // 6、确定一个值是哪种基本类型可以使用typeof操作符，而确定一个值是哪种引用类型可以使用instance操作符
      
      // // 所有变量（包含基本类型和引用类型）都存在于一个执行环境（也称为作用域）当中，这个执行环境决定了变量的生命周期，以及哪一部分代码可以访问其中的变量。以下是关于执行环境的几点总结
      // 1、执行环境有全局执行环境（也成为全局环境）和函数执行环境之分，
      // 2、每次进入一个新执行环境，都会创建一个用于搜索变量和函数的作用域链，
      // 3、函数的局部环境下不仅有权访问函数作用域重的变量，而且有权访问其包含（父）环境，乃至全局环境，
      // 4、全局环境只能访问在全局环境中定义的变量和函数，而不能直接访问局部环境中的任何数据，
      // 5、变量的执行环境有助于确定应该何时释放内存

      // // javascript是一门具有自动垃圾收集机制的编程语言，开发人员不必关心内存分配和回收问题。可以对JavaScript的垃圾收集例程作如下总结
      // 1、离开作用域的值将被自动标记为可以回收，因此将在垃圾收集期间被删除
      // 2、“标记清除”是目前主流的垃圾收集算法，这种算法的思想是给当前不使用的值加上标记，然后再回收其内存
      // 3、另一种垃圾收集算法是“引用计数”，这种算法的思想是跟踪记录所有值被引用的次数。javascript引擎目前都不再使用这种算法；但在ie中访问非原生javascript对象（如dom元素）时，这种算法仍然可能会导致问题
      // 4、当代码中存在循环引用现象是，”引用计数“算法就会导致问题
      // 5、解除变量的引用不仅有助于消除循环引用现象，而且对垃圾收集也有好处。为了确保有效地回收内存，应该及时解除不再使用的全局对象，全局对象属性以及循环引用变量的引用。

  </script>
</body>

</html>